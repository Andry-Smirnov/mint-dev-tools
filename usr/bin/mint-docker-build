#!/usr/bin/python3

import sys
import os
import argparse

def call(command, exit_on_failure=True):
    return_code = os.system(command)
    if return_code != 0 and exit_on_failure:
        print("ERROR: '%s' exited with return code %d" % (command, return_code))
        sys.exit(1)

parser = argparse.ArgumentParser(description='Build in a Docker image')
parser.add_argument("-i", "--image", help="Docker image", required=True)
parser.add_argument("-s", "--suffix", help="Version suffix", required=False)
parser.add_argument('project', nargs='?', default=None, help="A Linux Mint github project name (if not specified, the build occurs in the current directory)")
args = parser.parse_args()

# Create the output directory
output_directory = os.path.join(os.getcwd(), "docker_output", args.image.replace("/", "_"))
call("mkdir -p %s" % output_directory)

# Kill all containers for this image
call("sudo docker rm $(sudo docker stop $(sudo docker ps -a -q --filter ancestor=%s --format=\"{{.ID}}\"))" % args.image, exit_on_failure=False)

# Update the image
call("sudo docker pull %s" % args.image)

mintbuild = "mint-build"

if args.project is not None:
    mintbuild = "%s %s" % (mintbuild, args.project)

if args.suffix is not None:
    mintbuild = "%s -s %s" % (mintbuild, args.suffix)

if args.project is None:
    commands = "apt-get update; cd /volume_in; %(mintbuild)s; mv ../*.* /volume_out" % {'mintbuild':mintbuild}
else:
    commands = "apt-get update; %(mintbuild)s; mv %(project)s/*.* /volume_out" % {'mintbuild':mintbuild, 'project':args.project}

# Build in a container
call("sudo docker run -v %(cwd)s:/volume_in -v %(output_directory)s:/volume_out %(image)s /bin/sh -c \"%(commands)s\"" % {'cwd': os.getcwd(), 'output_directory': output_directory, 'image': args.image, 'commands': commands})

